buildscript {
    dependencies {
        classpath 'org.kohsuke:github-api:1.114'
    }

    repositories {
        gradlePluginPortal()
    }
}

version = project.mod_version
group = project.maven_group
def local_wunderlib = findProject(':wunderlib') != null
def rootModId = project.findProperty('root_mod_id') ?: 'wover'
def woverRootProject = rootProject.findProject(":WorldWeaver") ?: rootProject


allprojects { projIt ->
    if (projIt.name == "wunderlib") {
        return
    }
    apply plugin: 'java-library'
    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply plugin: 'maven-publish'
    apply plugin: 'net.neoforged.moddev'

    repositories {
        maven { url 'https://maven.neoforged.net/releases' }
        maven { url "https://maven.dblsaiko.net/" }
        maven { url "https://maven.shedaniel.me/" }
        maven { url 'https://maven.blamejared.com' }
        maven { url 'https://jitpack.io' }
        maven { url 'https://maven.terraformersmc.com/releases' }
        maven { url 'https://maven.terraformersmc.com' }
        maven { url 'https://maven.ambertation.de/releases' }
    }

    version = rootProject.mod_version
    group = rootProject.maven_group


    java {
        // Must be added before the split source sets are setup.
        withSourcesJar()
    }

    sourceSets {
        main {
            resources {
                srcDirs += [
                        'src/main/generated'
                ]
            }
            java {
                srcDirs += ['src/client/java', 'src/datagen/java']
            }
        }

        testmod {
            resources {
                srcDirs += [
                        'src/testmod/generated'
                ]
            }
            compileClasspath += main.compileClasspath
            runtimeClasspath += main.runtimeClasspath
        }

        testmodClient {
            compileClasspath += main.compileClasspath
            runtimeClasspath += main.runtimeClasspath

            compileClasspath += testmod.compileClasspath
            runtimeClasspath += testmod.runtimeClasspath
        }

        testmodDatagen {
            compileClasspath += main.compileClasspath
            runtimeClasspath += main.runtimeClasspath

            compileClasspath += testmod.compileClasspath
            runtimeClasspath += testmod.runtimeClasspath
            compileClasspath += testmodClient.compileClasspath
            runtimeClasspath += testmodClient.runtimeClasspath
        }
    }

    if (projIt == woverRootProject && rootProject != woverRootProject) {
        woverRootProject.subprojects.findAll { it.name != "wunderlib" }.each { sub ->
            sourceSets.main.output.classesDirs.from(sub.sourceSets.main.output.classesDirs)
            sourceSets.main.runtimeClasspath += sub.sourceSets.main.output
        }
    }

    if (projIt == woverRootProject) {
        tasks.matching { it.name == "writeDataLegacyClasspath" }.configureEach {
            doLast {
                def cpFile = file("${project.buildDir}/moddev/dataLegacyClasspath.txt")
                def existing = cpFile.exists() ? new LinkedHashSet<>(cpFile.readLines()) : new LinkedHashSet<>()

                def extraPaths = []
                def addOutputs = { proj ->
                    extraPaths.addAll(proj.sourceSets.main.output.classesDirs.files)
                    def resDir = proj.sourceSets.main.output.resourcesDir
                    if (resDir != null) extraPaths.add(resDir)
                }

                addOutputs(project)
                woverRootProject.subprojects.findAll { it.name != "wunderlib" }.each { sub -> addOutputs(sub) }

                def newEntries = extraPaths.collect { it.absolutePath }.findAll { it && !existing.contains(it) && new File(it).exists() }
                if (!newEntries.isEmpty()) {
                    cpFile.parentFile.mkdirs()
                    cpFile << System.lineSeparator() + newEntries.join(System.lineSeparator())
                }
            }
        }

    }

    def modId = projIt == woverRootProject ? rootModId : projIt.name.replace('-api', '')
    projIt.ext.mod_id = modId

    neoForge {
        version = project.neoforge_version
        def atFiles = [file("src/main/resources/META-INF/accesstransformer.cfg")]
        if (projIt == woverRootProject) {
            woverRootProject.subprojects.findAll { it.name != "wunderlib" }.each { sub ->
                atFiles.add(sub.file("src/main/resources/META-INF/accesstransformer.cfg"))
            }
        }
        atFiles = atFiles.findAll { it.exists() }
        if (!atFiles.isEmpty()) {
            accessTransformers = files(atFiles)
        }
        runs {
            client {
                client()
            }
            server {
                server()
            }
            data {
                data()
                programArguments.addAll(
                        "--mod", modId,
                        "--all",
                        "--output", file("src/main/generated").toString(),
                        "--existing", file("src/main/resources").toString()
                )
            }
        }
        mods {
            "${modId}" {
                sourceSet sourceSets.main
            }
        }
        // Datagen needs the resources output (neoforge.mods.toml) on the classpath, otherwise the mod
        // directory (classes only) is rejected as an invalid mod file.
        tasks.matching { it.name == "runData" }.configureEach {
            dependsOn(processResources)
            classpath += files(sourceSets.main.output.resourcesDir)
        }
    }

    tasks.matching { it.name == "createMinecraftArtifacts" }.configureEach {
        doNotTrackState("Work around Gradle 8.8 state tracking for moddev task outputs.")
    }

    configurations {
        dev {
            transitive true
            canBeResolved true
            canBeConsumed true
            extendsFrom api
        }
        localDev {
            extendsFrom dev
        }
    }

    dependencies {
        println("Adding dependencies for ${projIt.name}")
        dev sourceSets.main.output

        testmodImplementation sourceSets.main.output
        testmodClientImplementation sourceSets.main.output
        testmodClientImplementation sourceSets.testmod.output

        testmodDatagenImplementation sourceSets.main.output
        testmodDatagenImplementation sourceSets.testmod.output
        testmodDatagenImplementation sourceSets.testmodClient.output

        if (projIt.name != "wunderlib") {
            if (local_wunderlib) {
                implementation project(path: ":wunderlib")
            } else {
                implementation "de.ambertation:wunderlib:${project.wunderlib_version}"
            }
        }
    }

    tasks.withType(ProcessResources).configureEach {
        inputs.property "version", project.mod_version

        if (project != woverRootProject) {
            // Subprojects are libraries; omit mod metadata to avoid NeoForge mod scan errors.
            exclude("META-INF/neoforge.mods.toml")
        } else {
            filesMatching("META-INF/neoforge.mods.toml") {
                expand(
                        "mod_id": modId,
                        "version": project.mod_version,
                        "minecraft_version": project.minecraft_version,
                        "neoforge_version": project.neoforge_version
                )
            }
        }
    }

    tasks.withType(Jar).configureEach {
        // Avoid split-package JPMS errors on server launches.
        exclude("net/minecraft/**")
    }

    if (project == woverRootProject) {
        tasks.named("processResources") {
            // Pull subproject resources into the root mod output for mixin configs, etc.
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            woverRootProject.subprojects.findAll { it.name != "wunderlib" }.each { sub ->
                from(sub.file("src/main/resources")) {
                    exclude("META-INF/neoforge.mods.toml")
                }
            }
        }
    }

    // ensure that the encoding is set to UTF-8, no matter what the system default is
    // this fixes some edge cases with special characters not displaying correctly
    // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
        it.options.release = 21
    }

    tasks.withType(AbstractArchiveTask).configureEach {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    // Run this task after updating minecraft to regenerate any required resources
    tasks.register('generateResources') {
        group = "neoforge"
    }

    tasks.register('testmodJar', Jar) {
        from sourceSets.testmod.output
        from sourceSets.testmodClient.output
        from sourceSets.testmodDatagen.output
        destinationDirectory = new File(project.buildDir, "devlibs")
        archiveClassifier = "testmod"
    }

    [jar, sourcesJar].each {
        it.from(rootProject.file("LICENSE")) {
            rename { "${it}-${project.base.archivesName.get()}" }
        }
    }
}

tasks.sourcesJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}


//dependencies for the main Libraray
dependencies {
    subprojects.each {
        api project(path: "${it.path}")
    }
}

// Build a single "worldweaver" jar that includes all wover-* modules.
def woverProjects = subprojects.findAll { it.name != "wunderlib" }
def mergedMetaDir = layout.buildDirectory.dir("generated/merged-meta")
def mergedAccessTransformers = mergedMetaDir.map { it.file("META-INF/accesstransformer.cfg") }
def mergedServicesDir = mergedMetaDir.map { it.dir("META-INF/services") }

tasks.register("mergeWoverAccessTransformers") {
    def atFiles = []
    def rootAt = file("src/main/resources/META-INF/accesstransformer.cfg")
    if (rootAt.exists()) {
        atFiles.add(rootAt)
    }
    woverProjects.each { proj ->
        def atFile = proj.file("src/main/resources/META-INF/accesstransformer.cfg")
        if (atFile.exists()) {
            atFiles.add(atFile)
        }
    }
    inputs.files(atFiles)
    outputs.file(mergedAccessTransformers)
    doLast {
        def lines = new LinkedHashSet<String>()
        atFiles.each { atFile ->
            atFile.eachLine("UTF-8") { line ->
                def trimmed = line.trim()
                if (!trimmed.isEmpty()) {
                    lines.add(line)
                }
            }
        }
        def outFile = mergedAccessTransformers.get().asFile
        outFile.parentFile.mkdirs()
        outFile.text = lines.join("\n") + "\n"
    }
}

tasks.register("mergeWoverServices") {
    def serviceFiles = []
    def rootServicesDir = file("src/main/resources/META-INF/services")
    if (rootServicesDir.exists()) {
        serviceFiles.addAll(rootServicesDir.listFiles()?.findAll { it.isFile() } ?: [])
    }
    woverProjects.each { proj ->
        def servicesDir = proj.file("src/main/resources/META-INF/services")
        if (servicesDir.exists()) {
            serviceFiles.addAll(servicesDir.listFiles()?.findAll { it.isFile() } ?: [])
        }
    }
    inputs.files(serviceFiles)
    outputs.dir(mergedServicesDir)
    doLast {
        def entries = [:].withDefault { new LinkedHashSet<String>() }
        serviceFiles.each { serviceFile ->
            serviceFile.eachLine("UTF-8") { line ->
                def trimmed = line.trim()
                if (!trimmed.isEmpty() && !trimmed.startsWith("#")) {
                    entries[serviceFile.name].add(trimmed)
                }
            }
        }
        def outDir = mergedServicesDir.get().asFile
        outDir.mkdirs()
        entries.each { name, lines ->
            def outFile = new File(outDir, name)
            outFile.parentFile.mkdirs()
            outFile.text = lines.join("\n") + "\n"
        }
    }
}

tasks.named("processResources") {
    dependsOn("mergeWoverAccessTransformers", "mergeWoverServices")
    exclude("META-INF/accesstransformer.cfg", "META-INF/services/**")
    doLast {
        def outDir = destinationDir
        copy {
            from(mergedMetaDir)
            into(outDir)
            include("META-INF/accesstransformer.cfg", "META-INF/services/**")
        }
    }
}

tasks.named("jar") {
    dependsOn(woverProjects.collect { it.tasks.named("classes") })
    dependsOn("mergeWoverAccessTransformers", "mergeWoverServices")
    dependsOn(tasks.matching { it.name == "runData" })
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from(woverProjects.collect { it.sourceSets.main.output }) {
        exclude("META-INF/neoforge.mods.toml", "META-INF/accesstransformer.cfg", "META-INF/services/**")
    }
    from("src/main/generated")
}

task copyHighlightJs(type: Copy) {
    from 'javadoc/contrib' // Path to the local folder containing Highlight.js
    into "$buildDir/docs/javadoc/contrib" // Specify the destination folder in the generated Javadoc
}


javadoc {
    options {
        source = "17"
        encoding = "UTF-8"
        charSet = "UTF-8"
        memberLevel = JavadocMemberLevel.PROTECTED
        links("https://docs.oracle.com/en/java/javase/17/docs/api/")
        // Disable the crazy super-strict doclint tool in Java 8
        addStringOption("Xdoclint:none", "-quiet")
        addStringOption("noqualifier", "net.minecraft.*:com.mojang.*:net.neoforged.*")
        addBooleanOption("-allow-script-in-comments", true)
        tags(
                'apiNote:a:API Note:',
                'implSpec:a:Implementation Requirements:',
                'implNote:a:Implementation Note:'
        )
        header = "<script type=\"text/javascript\" src=\"../../../../../contrib/highlight/highlight.min.js\"></script>" +
                " <link rel=\"stylesheet\" href=\"../../../../../contrib/highlight/styles/default.min.css\"></link>" +
                " <script>window.onload=function(){var allPre,i,j;allPre=document.getElementsByTagName(\"pre\");console.log(allPre);for(i=0,j=allPre.length;i<j;i++){hljs.highlightElement(allPre[i]);}};</script>"

        stylesheetFile = file("javadoc/wover.css")
    }


    allprojects.each {
        source(it.sourceSets.main.allJava)
    }

    classpath = files(allprojects.collect { it.sourceSets.main.compileClasspath })
    include("**/api/**")
    include("de/ambertation/**")
    include("org/betterx/wover/util/**")
    failOnError true

    finalizedBy copyHighlightJs
}

jar {
    from "LICENSE"
}

configurations {
    dev {
        canBeConsumed true
        canBeResolved true
    }
    localDev {
        extendsFrom dev
    }
}

task javadocJar(type: Jar, dependsOn: [javadoc, copyHighlightJs]) {
    archiveClassifier = 'javadoc'
    from javadoc.destinationDir
}

artifacts {
    dev jar
    localDev jar
    archives sourcesJar
    archives javadocJar
}

idea {
    module {
        excludeDirs += file('javadoc')
        excludeDirs += file('gradle')
        excludeDirs += file('public')
        excludeDirs += file('tools')
        excludeDirs += file('bin')
        subprojects.each {
            excludeDirs += it.file('run')
            excludeDirs += it.file('run-server')
        }
    }
}
